# Задание для рефакторинга: Интернет-магазин

## Описание проекта

Этот проект представляет собой простой интернет-магазин, написанный на React с использованием Redux Toolkit. 

## Отчет о рефакторинге

Изначальный код содержал ряд типичных антипаттернов:

* дублирование данных в Redux Store
* хранение вычисляемых значений в состоянии
* использование строковых `type` при `dispatch`
* отсутствие мемоизации
* смешение ответственности компонентов и store

## Основные изменения и исправленные проблемы

### 1. Удаление вычисляемых данных из Redux Store

В `store` хранились вычисляемые значения:

* `cartCount`
* `totalPrice`
* `cartItemsCount`
* `cartTotalAmount`
* `cartTotalSum`

Эти данные пересчитывались вручную в каждом reducer’е, что приводило к дублированию логики и риску рассинхронизации данных.

После исправления в `store` остались только источники истины:

```js
products
cart
user
loading
error
```

Все производные значения теперь считаются через селекторы.

### 2. Использование `createSelector` для производных данных

Производные данные считались напрямую в reducers и в компонентах.

В store был внедрен `createSelector` из Redux Toolkit:

```js
export const selectCartCount = createSelector(
  [selectCart],
  cart => cart.reduce((sum, item) => sum + item.quantity, 0)
)

export const selectTotalPrice = createSelector(
  [selectCart],
  cart => cart.reduce((sum, item) => sum + item.price * item.quantity, 0)
)
```

Это обеспечивает единую точку расчета логики, отсутствие дублирования и мемоизацию:

### 3. Отказ от ручных `dispatch({ type })`

В компонентах использовались строковые `type`:

```js
dispatch({ type: 'app/addToCart', payload: product })
```

Это небезопасно и легко ломается при переименовании.

Для решения проблемы используются action creators:

```js
dispatch(addToCart(product))
```

Action creators обеспечивают типобезопасность, автодополнение и защиту от ошибок.

### 4. Мемоизация фильтрации и сортировки товаров

Фильтрация и сортировка выполнялись при каждом рендере:

```js
products.filter(...).sort(...)
```

Для решения была введена мемоизация, используется `useMemo`:

```js
const filteredProducts = useMemo(() => {
  ...
}, [products, searchTerm, selectedCategory, sortBy])
```

Это снижает количество вычислений, соответственно улучшает производительность.

### 5. Чистка side-effects (`setTimeout`)

`setTimeout` вызывался без очистки, что могло привести к ошибкам при размонтировании компонента.

Для решения была добавлена очистка эффектов:

```js
useEffect(() => {
  const timer = setTimeout(() => { ... }, 1000)
  return () => clearTimeout(timer)
}, [])
```

Это предотвращает утечки памяти и ошибки `setState on unmounted component`.

### 6. Разделение ответственности

* Компоненты отвечают только за UI и пользовательские события
* Redux Store отвечает только за состояние
* Вся бизнес-логика расчётов вынесена в селекторы

## Инструкции по запуску

1. Установите зависимости:
```bash
npm install
```

2. Запустите проект:
```bash
npm run dev
```

3. Откройте браузер по адресу `http://localhost:5173`


